<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ensemble Methods Playground</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        h1 { font-size: 1.4rem; color: #0f172a; margin-bottom: 4px; }
        .header-subtitle { font-size: 0.85rem; color: #64748b; }

        .reset-btn {
            background: white;
            color: #64748b;
            border: 1px solid #e2e8f0;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .reset-btn:hover { background: #f1f5f9; }

        /* Start Banner */
        .start-banner {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border-radius: 14px;
            padding: 20px 28px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .start-banner-icon { font-size: 2.2rem; }
        .start-banner-content h2 { font-size: 1rem; margin-bottom: 6px; }
        .start-banner-content p { font-size: 0.85rem; opacity: 0.9; }
        .start-banner-steps { display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap; }
        .start-step { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; }
        .step-num {
            background: rgba(255,255,255,0.2);
            width: 22px; height: 22px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: 600; font-size: 0.7rem;
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        .mode-tab {
            padding: 10px 20px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .mode-tab:hover { border-color: #8b5cf6; }
        .mode-tab.active {
            background: #8b5cf6;
            border-color: #8b5cf6;
            color: white;
        }

        /* Scenarios */
        .scenarios-bar {
            background: white;
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            flex-wrap: wrap;
        }
        .scenarios-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
        }
        .scenario-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .scenario-btn.stable { background: #dbeafe; color: #1e40af; }
        .scenario-btn.bias { background: #fef3c7; color: #92400e; }
        .scenario-btn.variance { background: #fce7f3; color: #9d174d; }
        .scenario-btn.challenge { background: #8b5cf6; color: white; }
        .scenario-hint {
            flex: 1;
            min-width: 180px;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #475569;
            display: none;
            border-left: 3px solid #8b5cf6;
        }
        .scenario-hint.visible { display: block; }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 16px;
            margin-bottom: 16px;
        }

        .charts-area { display: flex; flex-direction: column; gap: 12px; }

        .chart-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .chart-card {
            background: white;
            border-radius: 10px;
            padding: 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .chart-card.full { grid-column: 1 / -1; }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .chart-title { font-size: 0.75rem; font-weight: 600; color: #475569; }
        .chart-badge {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: #f1f5f9;
            color: #64748b;
        }

        canvas { display: block; width: 100%; }

        /* Sidebar */
        .sidebar { display: flex; flex-direction: column; gap: 12px; }

        .sidebar-card {
            background: white;
            border-radius: 10px;
            padding: 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .sidebar-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .control-group { margin-bottom: 12px; }
        .control-group:last-child { margin-bottom: 0; }
        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            font-weight: 500;
            color: #334155;
            margin-bottom: 6px;
        }
        .control-value {
            font-family: 'SF Mono', Monaco, monospace;
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #8b5cf6;
        }

        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
        }

        /* Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .metric-box {
            text-align: center;
            padding: 8px 6px;
            background: #f8fafc;
            border-radius: 6px;
        }
        .metric-label {
            font-size: 0.6rem;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
        }
        .metric-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: #1e293b;
            font-family: 'SF Mono', Monaco, monospace;
        }
        .metric-value.good { color: #16a34a; }
        .metric-value.warn { color: #d97706; }
        .metric-value.bad { color: #dc2626; }

        /* Comparison Table */
        .compare-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        .compare-table th, .compare-table td {
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }
        .compare-table th {
            background: #f8fafc;
            font-weight: 600;
            color: #64748b;
        }
        .compare-table .winner { background: #dcfce7; }

        /* Bias-Variance Panel */
        .bv-panel {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 1px solid #fbbf24;
            border-radius: 10px;
            padding: 14px;
            margin-top: 12px;
        }
        .bv-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .bv-dartboard {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 12px;
        }
        .dartboard-item {
            text-align: center;
        }
        .dartboard-item canvas {
            border-radius: 50%;
            background: white;
        }
        .dartboard-label {
            font-size: 0.65rem;
            color: #78350f;
            margin-top: 4px;
            font-weight: 500;
        }
        .bv-explanation {
            font-size: 0.75rem;
            color: #78350f;
            line-height: 1.5;
        }
        .bv-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .bv-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .bv-toggle label {
            font-size: 0.8rem;
            color: #78350f;
            cursor: pointer;
        }

        /* Insight */
        .insight-bar {
            background: linear-gradient(135deg, #faf5ff, #f3e8ff);
            border: 1px solid #c4b5fd;
            border-radius: 10px;
            padding: 14px 16px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .insight-icon { font-size: 1.2rem; }
        .insight-content { flex: 1; }
        .insight-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6d28d9;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .insight-text { font-size: 0.85rem; color: #4c1d95; }

        /* Help */
        .help-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        .help-header {
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            cursor: pointer;
            background: #f8fafc;
        }
        .help-title { font-size: 0.8rem; font-weight: 600; color: #475569; }
        .help-toggle { font-size: 0.7rem; color: #64748b; }
        .help-content {
            padding: 14px;
            display: none;
            border-top: 1px solid #e2e8f0;
        }
        .help-content.visible { display: block; }
        .help-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }
        .help-item {
            display: flex;
            gap: 8px;
            font-size: 0.75rem;
            color: #475569;
        }

        @media (max-width: 1000px) {
            .main-grid { grid-template-columns: 1fr; }
            .sidebar { flex-direction: row; flex-wrap: wrap; }
            .sidebar-card { flex: 1; min-width: 240px; }
        }
        @media (max-width: 650px) {
            .chart-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Ensemble Methods Playground</h1>
                <span class="header-subtitle">Learn why many weak learners beat one strong learner</span>
            </div>
            <button class="reset-btn" onclick="resetPlayground()">â†» Reset</button>
        </header>

        <div class="start-banner">
            <div class="start-banner-icon">ðŸŒ²ðŸŒ²ðŸŒ²</div>
            <div class="start-banner-content">
                <h2>The Wisdom of Crowds: Many Trees Beat One</h2>
                <p>A single tree overfits. An ensemble of trees averages out the noise.</p>
                <div class="start-banner-steps">
                    <div class="start-step"><span class="step-num">1</span> Compare 1 tree vs 10 trees</div>
                    <div class="start-step"><span class="step-num">2</span> Watch boundaries smooth out</div>
                    <div class="start-step"><span class="step-num">3</span> See variance drop</div>
                </div>
            </div>
        </div>

        <div class="mode-tabs">
            <div class="mode-tab active" role="button" tabindex="0" onclick="setMode('bagging')" onkeydown="if(event.key==='Enter'||event.key===' ')setMode('bagging')">ðŸŽ’ Bagging (Random Forest)</div>
            <div class="mode-tab" role="button" tabindex="0" onclick="setMode('boosting')" onkeydown="if(event.key==='Enter'||event.key===' ')setMode('boosting')">ðŸš€ Boosting</div>
        </div>

        <div class="scenarios-bar">
            <span class="scenarios-label">Try:</span>
            <button class="scenario-btn stable" onclick="loadPreset('stable')">âœ… Stable Pattern</button>
            <button class="scenario-btn bias" onclick="loadPreset('high_bias')">ðŸ“‰ High Bias</button>
            <button class="scenario-btn variance" onclick="loadPreset('high_variance')">ðŸ“ˆ High Variance</button>
            <button class="scenario-btn challenge" onclick="loadPreset('challenge')">ðŸŽ® Optimize</button>
            <div class="scenario-hint" id="scenarioHint"></div>
        </div>

        <div class="main-grid">
            <div class="charts-area">
                <div class="chart-row">
                    <div class="chart-card">
                        <div class="chart-header">
                            <span class="chart-title">Single Tree</span>
                            <span class="chart-badge" id="singleTreeBadge">depth=5</span>
                        </div>
                        <canvas id="singleTreeChart" height="240"></canvas>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">
                            <span class="chart-title" id="ensembleTitle">Random Forest (10 trees)</span>
                            <span class="chart-badge" id="ensembleBadge">bagging</span>
                        </div>
                        <canvas id="ensembleChart" height="240"></canvas>
                    </div>
                </div>

                <div class="chart-card full">
                    <div class="chart-header">
                        <span class="chart-title">Test Set Performance</span>
                    </div>
                    <canvas id="testChart" height="160"></canvas>
                </div>

                <div class="insight-bar">
                    <div class="insight-icon">ðŸŽ¯</div>
                    <div class="insight-content">
                        <div class="insight-title">Ensemble Insight</div>
                        <div class="insight-text" id="insightText">Loading...</div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="sidebar-card">
                    <div class="sidebar-title">Ensemble Settings</div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Number of Trees</span>
                            <span class="control-value" id="nTreesValue">10</span>
                        </div>
                        <input type="range" id="nTreesSlider" min="1" max="50" step="1" value="10">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Max Depth per Tree</span>
                            <span class="control-value" id="treeDepthValue">5</span>
                        </div>
                        <input type="range" id="treeDepthSlider" min="1" max="10" step="1" value="5">
                    </div>
                    <div class="control-group" id="boostingControls" style="display:none;">
                        <div class="control-label">
                            <span>Learning Rate</span>
                            <span class="control-value" id="learningRateValue">0.3</span>
                        </div>
                        <input type="range" id="learningRateSlider" min="0.05" max="1" step="0.05" value="0.3">
                    </div>
                </div>

                <div class="sidebar-card">
                    <div class="sidebar-title">Comparison</div>
                    <table class="compare-table">
                        <tr>
                            <th></th>
                            <th>Single Tree</th>
                            <th>Ensemble</th>
                        </tr>
                        <tr>
                            <td>Train Acc</td>
                            <td id="singleTrainAcc">--</td>
                            <td id="ensembleTrainAcc">--</td>
                        </tr>
                        <tr>
                            <td>Test Acc</td>
                            <td id="singleTestAcc">--</td>
                            <td id="ensembleTestAcc">--</td>
                        </tr>
                        <tr>
                            <td>Overfit Gap</td>
                            <td id="singleGap">--</td>
                            <td id="ensembleGap">--</td>
                        </tr>
                    </table>
                </div>

                <div class="sidebar-card">
                    <div class="sidebar-title">Data</div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Sample Size</span>
                            <span class="control-value" id="sampleValue">200</span>
                        </div>
                        <input type="range" id="sampleSlider" min="50" max="400" step="50" value="200">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Noise Level</span>
                            <span class="control-value" id="noiseValue">0.15</span>
                        </div>
                        <input type="range" id="noiseSlider" min="0" max="0.4" step="0.05" value="0.15">
                    </div>
                </div>

                <div class="bv-panel">
                    <div class="bv-title">ðŸŽ¯ Bias-Variance Tradeoff</div>
                    <div class="bv-toggle">
                        <input type="checkbox" id="showVarianceToggle" onchange="toggleVarianceViz()">
                        <label for="showVarianceToggle">Show variance across bootstrap samples</label>
                    </div>
                    <div class="bv-dartboard">
                        <div class="dartboard-item">
                            <canvas id="dartboardSingle" width="70" height="70"></canvas>
                            <div class="dartboard-label">Single Tree</div>
                        </div>
                        <div class="dartboard-item">
                            <canvas id="dartboardEnsemble" width="70" height="70"></canvas>
                            <div class="dartboard-label">Ensemble</div>
                        </div>
                    </div>
                    <div class="bv-explanation" id="bvExplanation">
                        <strong>Variance:</strong> How much predictions change with different training data.<br>
                        Single trees = high variance (scattered). Ensembles = low variance (clustered).
                    </div>
                </div>
            </div>
        </div>

        <div class="help-panel">
            <div class="help-header" onclick="toggleHelp()">
                <span class="help-title">ðŸ“– How to Read This</span>
                <span class="help-toggle" id="helpToggle">Show â–¼</span>
            </div>
            <div class="help-content" id="helpContent">
                <div class="help-grid">
                    <div class="help-item">
                        <span>ðŸŒ²</span>
                        <span><strong>Single tree:</strong> One model. Jagged, overfit-prone boundaries.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸŒ²ðŸŒ²ðŸŒ²</span>
                        <span><strong>Ensemble:</strong> Many trees averaged. Smoother, more stable.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸŽ’</span>
                        <span><strong>Bagging:</strong> Train each tree on random samples. Reduces variance.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸš€</span>
                        <span><strong>Boosting:</strong> Each tree fixes previous errors. Reduces bias.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸ“‰</span>
                        <span><strong>Overfit gap:</strong> Train-Test difference. Lower = better generalization.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸ”¢</span>
                        <span><strong>More trees:</strong> Usually better, with diminishing returns after ~50.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸŽ¯</span>
                        <span><strong>Bias:</strong> Systematic error. Model is too simple (underfit).</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸ“Š</span>
                        <span><strong>Variance:</strong> Sensitivity to training data. High = predictions change a lot.</span>
                    </div>
                    <div class="help-item">
                        <span>ðŸŽ¯</span>
                        <span><strong>Dartboard:</strong> Dots = predictions from different bootstrap samples. Tight cluster = low variance.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // STATE
        // ============================================
        let trainData = [];
        let testData = [];
        let sampleSize = 200;
        let noiseLevel = 0.15;
        let nTrees = 10;
        let treeDepth = 5;
        let learningRate = 0.3;
        let mode = 'bagging';
        let dataPattern = 'xor';
        let dprCached = window.devicePixelRatio || 1;
        let showVarianceViz = false;
        let varianceModels = { single: [], ensemble: [] };

        function sigmoid(z) {
            if (z > 20) return 1;
            if (z < -20) return 0;
            return 1 / (1 + Math.exp(-z));
        }

        // ============================================
        // SIMPLE DECISION TREE
        // ============================================
        class SimpleTree {
            constructor(maxDepth = 5, minSamples = 5) {
                this.maxDepth = maxDepth;
                this.minSamples = minSamples;
                this.root = null;
            }

            fit(data, sampleWeights = null) {
                this.root = this._buildNode(data, 0, sampleWeights);
            }

            _buildNode(data, depth, weights) {
                const node = { isLeaf: false, prediction: 0, samples: data.length };
                
                if (weights) {
                    let w0 = 0, w1 = 0;
                    data.forEach((d, i) => {
                        if (d.label === 0) w0 += weights[i] || 1;
                        else w1 += weights[i] || 1;
                    });
                    node.prediction = w1 > w0 ? 1 : 0;
                } else {
                    const p1 = data.filter(d => d.label === 1).length / data.length;
                    node.prediction = p1 >= 0.5 ? 1 : 0;
                }
                
                if (depth >= this.maxDepth || data.length < this.minSamples * 2) {
                    node.isLeaf = true;
                    return node;
                }

                let bestGain = 0;
                let bestSplit = null;

                for (const feature of ['x1', 'x2']) {
                    const values = data.map(d => d[feature]).sort((a, b) => a - b);
                    const uniqueVals = [...new Set(values)];
                    
                    for (let i = 0; i < uniqueVals.length - 1; i++) {
                        const thresh = (uniqueVals[i] + uniqueVals[i + 1]) / 2;
                        const left = data.filter(d => d[feature] <= thresh);
                        const right = data.filter(d => d[feature] > thresh);
                        
                        if (left.length < this.minSamples || right.length < this.minSamples) continue;
                        
                        const gain = this._infoGain(data, left, right);
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestSplit = { feature, thresh, left, right };
                        }
                    }
                }

                if (!bestSplit || bestGain <= 0.001) {
                    node.isLeaf = true;
                    return node;
                }

                node.feature = bestSplit.feature;
                node.threshold = bestSplit.thresh;
                node.left = this._buildNode(bestSplit.left, depth + 1, weights);
                node.right = this._buildNode(bestSplit.right, depth + 1, weights);
                
                return node;
            }

            _infoGain(parent, left, right) {
                const gini = arr => {
                    if (arr.length === 0) return 0;
                    const p = arr.filter(d => d.label === 1).length / arr.length;
                    return 2 * p * (1 - p);
                };
                const parentGini = gini(parent);
                const childGini = (left.length * gini(left) + right.length * gini(right)) / parent.length;
                return parentGini - childGini;
            }

            predict(point) {
                let node = this.root;
                while (!node.isLeaf) {
                    const val = point[node.feature];
                    node = val <= node.threshold ? node.left : node.right;
                }
                return node.prediction;
            }

            predictProba(point) {
                let node = this.root;
                while (!node.isLeaf) {
                    const val = point[node.feature];
                    node = val <= node.threshold ? node.left : node.right;
                }
                return node.prediction;
            }
        }

        // ============================================
        // ENSEMBLE
        // ============================================
        class RandomForest {
            constructor(nTrees, maxDepth) {
                this.nTrees = nTrees;
                this.maxDepth = maxDepth;
                this.trees = [];
            }

            fit(data) {
                this.trees = [];
                for (let i = 0; i < this.nTrees; i++) {
                    const sample = this._bootstrap(data);
                    const tree = new SimpleTree(this.maxDepth, 3);
                    tree.fit(sample);
                    this.trees.push(tree);
                }
            }

            _bootstrap(data) {
                const sample = [];
                for (let i = 0; i < data.length; i++) {
                    sample.push(data[Math.floor(Math.random() * data.length)]);
                }
                return sample;
            }

            predict(point) {
                const votes = this.trees.map(t => t.predict(point));
                const sum = votes.reduce((a, b) => a + b, 0);
                return sum > this.nTrees / 2 ? 1 : 0;
            }

            predictProba(point) {
                const votes = this.trees.map(t => t.predict(point));
                return votes.reduce((a, b) => a + b, 0) / this.nTrees;
            }
        }

        class RegressionTree {
            constructor(maxDepth = 3, minSamples = 5) {
                this.maxDepth = maxDepth;
                this.minSamples = minSamples;
                this.root = null;
            }

            fit(data) {
                this.root = this._buildNode(data, 0);
            }

            _buildNode(data, depth) {
                const node = { isLeaf: false, prediction: 0, samples: data.length };
                if (data.length === 0) {
                    node.isLeaf = true;
                    return node;
                }

                const meanTarget = data.reduce((sum, d) => sum + d.target, 0) / data.length;
                node.prediction = meanTarget;

                if (depth >= this.maxDepth || data.length < this.minSamples * 2) {
                    node.isLeaf = true;
                    return node;
                }

                let bestGain = 0;
                let bestSplit = null;
                const parentMse = this._mse(data);

                for (const feature of ['x1', 'x2']) {
                    const uniqueVals = [...new Set(data.map(d => d[feature]))].sort((a, b) => a - b);
                    for (let i = 0; i < uniqueVals.length - 1; i++) {
                        const thresh = (uniqueVals[i] + uniqueVals[i + 1]) / 2;
                        const left = data.filter(d => d[feature] <= thresh);
                        const right = data.filter(d => d[feature] > thresh);

                        if (left.length < this.minSamples || right.length < this.minSamples) continue;

                        const childMse = (left.length * this._mse(left) + right.length * this._mse(right)) / data.length;
                        const gain = parentMse - childMse;
                        if (gain > bestGain) {
                            bestGain = gain;
                            bestSplit = { feature, thresh, left, right };
                        }
                    }
                }

                if (!bestSplit || bestGain <= 0.000001) {
                    node.isLeaf = true;
                    return node;
                }

                node.feature = bestSplit.feature;
                node.threshold = bestSplit.thresh;
                node.left = this._buildNode(bestSplit.left, depth + 1);
                node.right = this._buildNode(bestSplit.right, depth + 1);
                return node;
            }

            _mse(data) {
                if (data.length === 0) return 0;
                const mean = data.reduce((sum, d) => sum + d.target, 0) / data.length;
                return data.reduce((sum, d) => sum + Math.pow(d.target - mean, 2), 0) / data.length;
            }

            predict(point) {
                let node = this.root;
                while (node && !node.isLeaf) {
                    const val = point[node.feature];
                    node = val <= node.threshold ? node.left : node.right;
                }
                return node ? node.prediction : 0;
            }
        }

        class GradientBoosting {
            constructor(nTrees, maxDepth, learningRate) {
                this.nTrees = nTrees;
                this.maxDepth = maxDepth;
                this.lr = learningRate;
                this.trees = [];
                this.initialPred = 0;
            }

            fit(data) {
                this.trees = [];
                const p = data.filter(d => d.label === 1).length / data.length;
                const clippedP = Math.max(0.001, Math.min(0.999, p));
                this.initialPred = Math.log(clippedP / (1 - clippedP));

                const scores = new Array(data.length).fill(this.initialPred);

                for (let i = 0; i < this.nTrees; i++) {
                    const residuals = data.map((d, j) => {
                        const prob = sigmoid(scores[j]);
                        return { x1: d.x1, x2: d.x2, target: d.label - prob };
                    });

                    const tree = new RegressionTree(this.maxDepth, 3);
                    tree.fit(residuals);
                    this.trees.push(tree);

                    data.forEach((d, j) => {
                        scores[j] += this.lr * tree.predict(d);
                    });
                }
            }

            predict(point) {
                let score = this.initialPred;
                for (const tree of this.trees) {
                    score += this.lr * tree.predict(point);
                }
                return score > 0 ? 1 : 0;
            }

            predictProba(point) {
                let score = this.initialPred;
                for (const tree of this.trees) {
                    score += this.lr * tree.predict(point);
                }
                return sigmoid(score);
            }
        }

        // ============================================
        // DATA
        // ============================================
        function generateData(n, noise) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const x1 = Math.random() * 2 - 1;
                const x2 = Math.random() * 2 - 1;
                let label = ((x1 > 0) !== (x2 > 0)) ? 1 : 0;
                if (Math.random() < noise) label = 1 - label;
                data.push({ x1, x2, label });
            }
            return data;
        }

        function splitData() {
            const all = generateData(sampleSize, noiseLevel);
            const shuffled = all.sort(() => Math.random() - 0.5);
            const splitIdx = Math.floor(shuffled.length * 0.7);
            trainData = shuffled.slice(0, splitIdx);
            testData = shuffled.slice(splitIdx);
        }

        function calcAccuracy(model, data) {
            if (data.length === 0) return 0;
            const correct = data.filter(d => model.predict(d) === d.label).length;
            return correct / data.length;
        }

        // ============================================
        // CANVAS
        // ============================================
        function setupCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dprCached;
            canvas.height = rect.height * dprCached;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dprCached, dprCached);
            return { width: rect.width, height: rect.height, ctx };
        }

        function drawDecisionChart(canvas, model, title, modelArray = null) {
            const { width, height, ctx } = setupCanvas(canvas);
            const pad = { top: 10, right: 10, bottom: 25, left: 25 };
            const plotW = width - pad.left - pad.right;
            const plotH = height - pad.top - pad.bottom;

            ctx.clearRect(0, 0, width, height);

            const sx = x => pad.left + (x + 1) / 2 * plotW;
            const sy = y => pad.top + (1 - (y + 1) / 2) * plotH;

            // Decision regions - show variance if enabled
            const res = 40;
            const cellW = plotW / res;
            const cellH = plotH / res;

            if (showVarianceViz && modelArray && modelArray.length > 0) {
                // Show variance across bootstrap samples
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const x1 = (i / res) * 2 - 1;
                        const x2 = 1 - (j / res) * 2;
                        const point = { x1, x2 };
                        
                        const preds = modelArray.map(m => m.predictProba ? m.predictProba(point) : m.predict(point));
                        const meanPred = preds.reduce((a, b) => a + b, 0) / preds.length;
                        const predVar = variance(preds);
                        
                        // Color by mean prediction
                        const red = Math.floor(239 * meanPred + 59 * (1 - meanPred));
                        const green = Math.floor(68 * meanPred + 130 * (1 - meanPred));
                        const blue = Math.floor(68 * meanPred + 246 * (1 - meanPred));
                        
                        // Higher variance = more saturated/darker
                        const varIntensity = Math.min(predVar * 10, 0.6);
                        ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${0.15 + varIntensity})`;
                        ctx.fillRect(pad.left + i * cellW, pad.top + j * cellH, cellW + 1, cellH + 1);
                    }
                }
            } else if (model) {
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const x1 = (i / res) * 2 - 1;
                        const x2 = 1 - (j / res) * 2;
                        
                        let prob;
                        if (model.predictProba) {
                            prob = model.predictProba({ x1, x2 });
                        } else {
                            prob = model.predict({ x1, x2 });
                        }
                        
                        const red = Math.floor(239 * prob + 59 * (1 - prob));
                        const green = Math.floor(68 * prob + 130 * (1 - prob));
                        const blue = Math.floor(68 * prob + 246 * (1 - prob));
                        
                        ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, 0.25)`;
                        ctx.fillRect(pad.left + i * cellW, pad.top + j * cellH, cellW + 1, cellH + 1);
                    }
                }
            }

            // Grid
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(sx(0), pad.top);
            ctx.lineTo(sx(0), height - pad.bottom);
            ctx.moveTo(pad.left, sy(0));
            ctx.lineTo(width - pad.right, sy(0));
            ctx.stroke();

            // Training points
            trainData.forEach(d => {
                ctx.fillStyle = d.label === 1 ? '#ef4444' : '#3b82f6';
                ctx.beginPath();
                ctx.arc(sx(d.x1), sy(d.x2), 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawTestChart(canvas, singleTree, ensemble) {
            const { width, height, ctx } = setupCanvas(canvas);
            const pad = { top: 10, right: 10, bottom: 25, left: 25 };
            const plotW = width - pad.left - pad.right;
            const plotH = height - pad.top - pad.bottom;

            ctx.clearRect(0, 0, width, height);

            const sx = x => pad.left + (x + 1) / 2 * plotW;
            const sy = y => pad.top + (1 - (y + 1) / 2) * plotH;

            // Draw test points with correctness
            testData.forEach(d => {
                const singlePred = singleTree ? singleTree.predict(d) : 0;
                const ensemblePred = ensemble ? ensemble.predict(d) : 0;
                const singleCorrect = singlePred === d.label;
                const ensembleCorrect = ensemblePred === d.label;

                const px = sx(d.x1);
                const py = sy(d.x2);

                // Left half: single tree prediction
                ctx.fillStyle = singleCorrect ? '#22c55e' : '#ef4444';
                ctx.beginPath();
                ctx.arc(px - 4, py, 4, 0, Math.PI * 2);
                ctx.fill();

                // Right half: ensemble prediction
                ctx.fillStyle = ensembleCorrect ? '#22c55e' : '#ef4444';
                ctx.beginPath();
                ctx.arc(px + 4, py, 4, 0, Math.PI * 2);
                ctx.fill();

                // True label indicator
                ctx.strokeStyle = d.label === 1 ? '#991b1b' : '#1e40af';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(px, py, 7, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Legend
            ctx.font = '10px -apple-system';
            ctx.fillStyle = '#64748b';
            ctx.textAlign = 'left';
            ctx.fillText('Left dot = Single Tree | Right dot = Ensemble | Green = Correct', pad.left, height - 5);
        }

        // ============================================
        // MAIN UPDATE
        // ============================================
        let singleTree, ensemble;

        function updateModels() {
            singleTree = new SimpleTree(treeDepth, 3);
            singleTree.fit(trainData);

            if (mode === 'bagging') {
                ensemble = new RandomForest(nTrees, treeDepth);
            } else {
                ensemble = new GradientBoosting(nTrees, Math.min(treeDepth, 3), learningRate);
            }
            ensemble.fit(trainData);
        }

        function updateUI() {
            const singleTrainAcc = calcAccuracy(singleTree, trainData);
            const singleTestAcc = calcAccuracy(singleTree, testData);
            const ensembleTrainAcc = calcAccuracy(ensemble, trainData);
            const ensembleTestAcc = calcAccuracy(ensemble, testData);

            document.getElementById('singleTrainAcc').textContent = (singleTrainAcc * 100).toFixed(1) + '%';
            document.getElementById('singleTestAcc').textContent = (singleTestAcc * 100).toFixed(1) + '%';
            document.getElementById('ensembleTrainAcc').textContent = (ensembleTrainAcc * 100).toFixed(1) + '%';
            document.getElementById('ensembleTestAcc').textContent = (ensembleTestAcc * 100).toFixed(1) + '%';

            const singleGap = singleTrainAcc - singleTestAcc;
            const ensembleGap = ensembleTrainAcc - ensembleTestAcc;
            document.getElementById('singleGap').textContent = (singleGap * 100).toFixed(1) + '%';
            document.getElementById('ensembleGap').textContent = (ensembleGap * 100).toFixed(1) + '%';

            // Highlight winner
            document.getElementById('singleTestAcc').parentElement.classList.toggle('winner', singleTestAcc > ensembleTestAcc);
            document.getElementById('ensembleTestAcc').parentElement.classList.toggle('winner', ensembleTestAcc > singleTestAcc);

            // Insight
            let insight = '';
            if (ensembleTestAcc > singleTestAcc + 0.03) {
                insight = `<strong>Ensemble wins!</strong> ${nTrees} trees achieve ${(ensembleTestAcc*100).toFixed(0)}% test accuracy vs ${(singleTestAcc*100).toFixed(0)}% for a single tree. The ensemble's smoother boundaries generalize better.`;
            } else if (singleTestAcc > ensembleTestAcc + 0.03) {
                insight = `<strong>Single tree is competitive!</strong> With low noise and good depth, one tree can match an ensemble. But ensembles are more robust to hyperparameter choices.`;
            } else {
                insight = `<strong>Close call.</strong> Both models perform similarly. The ensemble has a smaller overfit gap (${(ensembleGap*100).toFixed(0)}% vs ${(singleGap*100).toFixed(0)}%), making it more reliable.`;
            }
            document.getElementById('insightText').innerHTML = insight;

            document.getElementById('singleTreeBadge').textContent = `depth=${treeDepth}`;
            document.getElementById('ensembleTitle').textContent = mode === 'bagging' 
                ? `Random Forest (${nTrees} trees)` 
                : `Gradient Boosting (${nTrees} rounds)`;
            document.getElementById('ensembleBadge').textContent = mode;
        }

        function drawAll() {
            updateModels();
            
            if (showVarianceViz && varianceModels.single.length > 0) {
                drawDecisionChart(document.getElementById('singleTreeChart'), singleTree, 'Single Tree', varianceModels.single);
                drawDecisionChart(document.getElementById('ensembleChart'), ensemble, 'Ensemble', varianceModels.ensemble);
                drawDartboards();
            } else {
                drawDecisionChart(document.getElementById('singleTreeChart'), singleTree, 'Single Tree');
                drawDecisionChart(document.getElementById('ensembleChart'), ensemble, 'Ensemble');
            }
            
            drawTestChart(document.getElementById('testChart'), singleTree, ensemble);
            updateUI();
        }

        // ============================================
        // EVENTS
        // ============================================
        document.getElementById('nTreesSlider').addEventListener('input', function() {
            nTrees = parseInt(this.value);
            document.getElementById('nTreesValue').textContent = nTrees;
            drawAll();
        });

        document.getElementById('treeDepthSlider').addEventListener('input', function() {
            treeDepth = parseInt(this.value);
            document.getElementById('treeDepthValue').textContent = treeDepth;
            drawAll();
        });

        document.getElementById('learningRateSlider').addEventListener('input', function() {
            learningRate = parseFloat(this.value);
            document.getElementById('learningRateValue').textContent = learningRate.toFixed(2);
            drawAll();
        });

        document.getElementById('sampleSlider').addEventListener('input', function() {
            sampleSize = parseInt(this.value);
            document.getElementById('sampleValue').textContent = sampleSize;
            splitData();
            drawAll();
        });

        document.getElementById('noiseSlider').addEventListener('input', function() {
            noiseLevel = parseFloat(this.value);
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
            splitData();
            drawAll();
        });

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.mode-tab:nth-child(${mode === 'bagging' ? 1 : 2})`).classList.add('active');
            document.getElementById('boostingControls').style.display = mode === 'boosting' ? 'block' : 'none';
            drawAll();
        }

        const presets = {
            stable: {
                nTrees: 20, depth: 4, noise: 0.1, samples: 200, lr: 0.3,
                hint: '<strong>Stable pattern:</strong> Low noise, moderate depth. Ensemble should slightly outperform with smoother boundaries.'
            },
            high_bias: {
                nTrees: 5, depth: 1, noise: 0.05, samples: 200, lr: 0.1,
                hint: '<strong>High bias (underfitting):</strong> Very shallow trees. Both models struggle. Try increasing depth.'
            },
            high_variance: {
                nTrees: 10, depth: 10, noise: 0.2, samples: 150, lr: 0.5,
                hint: '<strong>High variance (overfitting):</strong> Deep trees + noise = overfit. Ensemble should show smaller train-test gap.'
            },
            challenge: {
                nTrees: 1, depth: 5, noise: 0.15, samples: 200, lr: 0.3,
                hint: '<strong>Challenge:</strong> Start with 1 tree. Increase until test accuracy stops improving. Find the sweet spot!'
            }
        };

        function loadPreset(name) {
            const p = presets[name];
            nTrees = p.nTrees;
            treeDepth = p.depth;
            noiseLevel = p.noise;
            sampleSize = p.samples;
            learningRate = p.lr;

            document.getElementById('nTreesSlider').value = nTrees;
            document.getElementById('treeDepthSlider').value = treeDepth;
            document.getElementById('noiseSlider').value = noiseLevel;
            document.getElementById('sampleSlider').value = sampleSize;
            document.getElementById('learningRateSlider').value = learningRate;

            document.getElementById('nTreesValue').textContent = nTrees;
            document.getElementById('treeDepthValue').textContent = treeDepth;
            document.getElementById('noiseValue').textContent = noiseLevel.toFixed(2);
            document.getElementById('sampleValue').textContent = sampleSize;
            document.getElementById('learningRateValue').textContent = learningRate.toFixed(2);

            splitData();
            drawAll();

            document.getElementById('scenarioHint').innerHTML = p.hint;
            document.getElementById('scenarioHint').classList.add('visible');
        }

        function resetPlayground() {
            nTrees = 10;
            treeDepth = 5;
            noiseLevel = 0.15;
            sampleSize = 200;
            learningRate = 0.3;
            mode = 'bagging';

            document.getElementById('nTreesSlider').value = 10;
            document.getElementById('treeDepthSlider').value = 5;
            document.getElementById('noiseSlider').value = 0.15;
            document.getElementById('sampleSlider').value = 200;
            document.getElementById('learningRateSlider').value = 0.3;

            document.getElementById('nTreesValue').textContent = '10';
            document.getElementById('treeDepthValue').textContent = '5';
            document.getElementById('noiseValue').textContent = '0.15';
            document.getElementById('sampleValue').textContent = '200';
            document.getElementById('learningRateValue').textContent = '0.30';
            document.getElementById('scenarioHint').classList.remove('visible');

            setMode('bagging');
            splitData();
            drawAll();
        }

        function toggleHelp() {
            const content = document.getElementById('helpContent');
            const toggle = document.getElementById('helpToggle');
            const isVisible = content.classList.toggle('visible');
            toggle.textContent = isVisible ? 'Hide â–²' : 'Show â–¼';
        }

        // ============================================
        // BIAS-VARIANCE VISUALIZATION
        // ============================================
        function toggleVarianceViz() {
            showVarianceViz = document.getElementById('showVarianceToggle').checked;
            if (showVarianceViz) {
                computeVarianceModels();
            }
            drawAll();
        }

        function computeVarianceModels() {
            const nBootstraps = 5;
            varianceModels.single = [];
            varianceModels.ensemble = [];
            
            for (let i = 0; i < nBootstraps; i++) {
                const bootstrapData = [];
                for (let j = 0; j < trainData.length; j++) {
                    bootstrapData.push(trainData[Math.floor(Math.random() * trainData.length)]);
                }
                
                const singleT = new SimpleTree(treeDepth, 3);
                singleT.fit(bootstrapData);
                varianceModels.single.push(singleT);
                
                if (mode === 'bagging') {
                    const ensembleT = new RandomForest(nTrees, treeDepth);
                    ensembleT.fit(bootstrapData);
                    varianceModels.ensemble.push(ensembleT);
                } else {
                    const ensembleT = new GradientBoosting(nTrees, Math.min(treeDepth, 3), learningRate);
                    ensembleT.fit(bootstrapData);
                    varianceModels.ensemble.push(ensembleT);
                }
            }
        }

        function drawDartboards() {
            const testPoint = { x1: 0.3, x2: 0.3 };
            const trueLabel = ((testPoint.x1 > 0) !== (testPoint.x2 > 0)) ? 1 : 0;
            
            drawDartboard('dartboardSingle', varianceModels.single, testPoint, trueLabel);
            drawDartboard('dartboardEnsemble', varianceModels.ensemble, testPoint, trueLabel);
            
            const singlePreds = varianceModels.single.map(m => m.predictProba ? m.predictProba(testPoint) : m.predict(testPoint));
            const ensemblePreds = varianceModels.ensemble.map(m => m.predictProba ? m.predictProba(testPoint) : m.predict(testPoint));
            
            const singleVar = variance(singlePreds);
            const ensembleVar = variance(ensemblePreds);
            
            const explanation = document.getElementById('bvExplanation');
            explanation.innerHTML = `
                <strong>At test point (0.3, 0.3):</strong><br>
                Single tree variance: <strong>${(singleVar * 100).toFixed(1)}%</strong><br>
                Ensemble variance: <strong>${(ensembleVar * 100).toFixed(1)}%</strong><br>
                ${ensembleVar < singleVar ? 'âœ… Ensemble is more stable!' : 'âš ï¸ Unusual - try more trees'}
            `;
        }

        function variance(arr) {
            if (arr.length === 0) return 0;
            const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
            return arr.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / arr.length;
        }

        function drawDartboard(canvasId, models, testPoint, trueLabel) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const r = Math.min(w, h) / 2 - 4;
            
            ctx.clearRect(0, 0, w, h);
            
            ctx.fillStyle = '#f8fafc';
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(cx, cy, r * i / 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.fillStyle = trueLabel === 1 ? '#fecaca' : '#bfdbfe';
            ctx.beginPath();
            ctx.arc(cx, cy, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = trueLabel === 1 ? '#ef4444' : '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (models.length > 0) {
                const preds = models.map(m => m.predictProba ? m.predictProba(testPoint) : m.predict(testPoint));
                const meanPred = preds.reduce((a, b) => a + b, 0) / preds.length;
                
                preds.forEach((pred, i) => {
                    const angle = (i / preds.length) * Math.PI * 2 - Math.PI / 2;
                    const dist = Math.abs(pred - trueLabel) * r * 0.8;
                    const jitterAngle = angle + (Math.random() - 0.5) * 0.5;
                    const px = cx + Math.cos(jitterAngle) * dist;
                    const py = cy + Math.sin(jitterAngle) * dist;
                    
                    ctx.fillStyle = '#8b5cf6';
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        // ============================================
        // INIT
        // ============================================
        window.addEventListener('resize', () => {
            dprCached = window.devicePixelRatio || 1;
            drawAll();
        });

        splitData();
        drawAll();
    </script>
</body>
</html>
